---
import { Icon } from 'astro-icon/components';
import Image from '~/components/common/Image.astro';
import GradientHeroSection from './GradientHeroSection.astro';
import Button from '../ui/Button.astro';
import type { ImageMetadata } from 'astro';

interface ButtonProps {
  href: string;
  icon?: string;
  label: string;
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'blue' | 'outline-blue';
  size?: 'sm' | 'md' | 'lg';
}

interface Stat {
  icon: string;
  value: string;
}

interface FloatingIcon {
  name: string;
  size: 'sm' | 'md' | 'lg';
  position: {
    top?: string;
    left?: string;
    right?: string;
    bottom?: string;
  };
  rotate?: string;
  animation?: 'float' | 'float-delayed' | 'none';
}

interface Props {
  logo: ImageMetadata;
  logoClass?: string;
  heroImage: ImageMetadata | string;
  quote: string;
  quoteColor?: string;
  stats?: Array<Stat>;
  buttons?: Array<ButtonProps>;
  floatingIcons?: Array<FloatingIcon>;
  /**
   * Contrôle si la flèche de défilement doit être affichée
   * @default true
   */
  showScrollArrow?: boolean;
  /**
   * Contrôle si la flèche de défilement doit être affichée sur mobile
   * @default false
   */
  showScrollArrowOnMobile?: boolean;
  /**
   * ID de l'élément cible pour le défilement
   */
  scrollTargetId?: string;
  /**
   * Texte à afficher au-dessus de la flèche
   * @default "En savoir plus"
   */
  scrollLabel?: string;
  imageBackgroundColor?: string;
}

const { 
  logo, 
  logoClass = "w-[280px] md:w-[400px] h-auto mx-auto md:mx-0",
  heroImage, 
  quote,
  quoteColor = '--ootb-yellow',
  stats = [],
  buttons = [],
  floatingIcons = [],
  showScrollArrow = true,
  showScrollArrowOnMobile = false,
  scrollTargetId,
  scrollLabel = "En savoir plus",
  imageBackgroundColor = '--ootb-yellow'
} = Astro.props;

const isHeroImageString = typeof heroImage === 'string';

const getIconSize = (size: 'sm' | 'md' | 'lg') => {
  switch (size) {
    case 'sm': return 'w-16 h-16';
    case 'md': return 'w-20 h-28';
    case 'lg': return 'w-24 h-32';
  }
};
---

<GradientHeroSection>
  <div class="relative z-10 container mx-auto px-4 pt-12 md:pt-20">
    <div class="max-w-6xl mx-auto">
      <div class="grid md:grid-cols-2 gap-12 items-center">
        <div class="text-center md:text-left px-4 md:px-0 space-y-6 md:space-y-8">
          <h1 class="text-left pb-8">
            <Image
              src={logo}
              alt="Out of the Books"
              class={`${logoClass} max-w-full`}
              widths={[200, 300]}
              sizes="(max-width: 768px) 200px, 300px"
              loading="eager"
              decoding="async"
            />
          </h1>
          <blockquote class="text-lg md:text-xl lg:text-2xl text-white/90 font-light border-l-4 pl-4 md:pl-6 leading-relaxed max-w-3xl mt-10 md:mt-12" style={`border-color: var(${quoteColor})`}>
            {quote}
          </blockquote>

          {stats.length > 0 && (
            <div class="flex flex-wrap gap-3 md:gap-4 justify-center md:justify-start">
              {stats.map(({ icon, value }) => (
                <div class="flex items-center gap-3 bg-white/10 backdrop-blur-sm rounded-lg px-4 py-2">
                  <Icon name={icon} class="w-5 h-5 text-white" />
                  <span class="text-white text-sm md:text-base">{value}</span>
                </div>
              ))}
            </div>
          )}

          {buttons.length > 0 && (
            <div class="flex flex-wrap gap-3 md:gap-4 justify-center md:justify-start">
              {buttons.map(({ href, icon, label, variant = 'primary', size = 'lg' }) => (
                <Button {href} {variant} {size} {icon}>
                  {label}
                </Button>
              ))}
            </div>
          )}
        </div>

        <!-- Image avec espace réduit et plus de padding -->
        <div class="relative mt-8 md:mt-0 md:block px-4 md:px-6">
          <div class="relative z-10 max-w-[95%] mx-auto">
            {isHeroImageString ? (
              <img
                src={heroImage}
                alt="Hero image"
                class="rounded-2xl shadow-xl w-full"
                loading="eager"
              />
            ) : (
              <Image
                src={heroImage}
                alt="Hero image"
                class="rounded-2xl shadow-xl w-full"
                widths={[400, 800]}
                sizes="(max-width: 768px) 100vw, 800px"
                aspectRatio="4:3"
                loading="eager"
                decoding="async"
              />
            )}
          </div>
          <!-- Élément décoratif derrière l'image -->
          <div 
            class="absolute inset-0 rounded-2xl transform rotate-3 translate-x-4 translate-y-4 -z-10 max-w-[95%] mx-auto"
            style={`background-color: var(${imageBackgroundColor})`}
          ></div>
          
          <!-- ScrollDownArrow intégré au milieu en dessous de l'image (desktop) -->
          {showScrollArrow && scrollTargetId && (
            <div class="hidden md:block absolute z-30 bottom-0 left-1/2 transform translate-y-[100%] translate-x-[-50%]">
              <div class="flex flex-col items-center group cursor-pointer" data-target-id={scrollTargetId}>
                <!-- Applique le fond flou uniquement sur le texte -->
                <p class="font-handwritten text-white text-2xl md:text-3xl mb-3 transform -rotate-3 relative group-hover:text-[--ootb-purple] transition-colors duration-300">
                  <span class="absolute inset-0 bg-white/10 backdrop-blur-md rounded-xl -z-10 scale-110 px-8"></span>
                  {scrollLabel}
                </p>
                
                <!-- La flèche est sans flou -->
                <div class="arrow-animation hover:scale-110 transition-all duration-300">
                  <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    fill="none" 
                    viewBox="0 0 24 24" 
                    stroke-width="2.5" 
                    stroke="currentColor" 
                    class="w-8 h-8 md:w-10 md:h-10 text-white group-hover:text-[--ootb-purple] transition-colors duration-300 drop-shadow-md"
                  >
                    <path 
                      stroke-linecap="round" 
                      stroke-linejoin="round" 
                      d="M19.5 13.5L12 21m0 0l-7.5-7.5M12 21V3"
                    />
                  </svg>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  </div>

  <slot />

  <!-- ScrollDownArrow pour mobile (en bas) -->
  {showScrollArrow && showScrollArrowOnMobile && scrollTargetId && (
    <div class="md:hidden relative mt-8 mb-4">
      <div class="flex flex-col items-center mx-auto w-max group cursor-pointer" data-target-id={scrollTargetId}>
        <!-- Applique le fond flou uniquement sur le texte (mobile) -->
        <p class="font-handwritten text-white text-2xl mb-3 transform -rotate-3 relative group-hover:text-[--ootb-purple] transition-colors duration-300">
          <span class="absolute inset-0 bg-white/10 backdrop-blur-md rounded-xl -z-10 scale-110 px-8"></span>
          {scrollLabel}
        </p>
        
        <!-- La flèche est sans flou (mobile) -->
        <div class="arrow-animation hover:scale-110 transition-all duration-300">
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            fill="none" 
            viewBox="0 0 24 24" 
            stroke-width="2.5" 
            stroke="currentColor" 
            class="w-8 h-8 text-white group-hover:text-[--ootb-purple] transition-colors duration-300 drop-shadow-md"
          >
            <path 
              stroke-linecap="round" 
              stroke-linejoin="round" 
              d="M19.5 13.5L12 21m0 0l-7.5-7.5M12 21V3"
            />
          </svg>
        </div>
      </div>
    </div>
  )}

  <!-- Icônes flottantes -->
  {floatingIcons.map(({ name, size, position, rotate, animation }) => (
    <div
      class:list={[
        'absolute',
        getIconSize(size),
        'opacity-30',
        { 'transition-transform hover:-translate-y-2 duration-1000': !animation },
        { 'animate-float': animation === 'float' },
        { 'animate-float-delayed': animation === 'float-delayed' }
      ]}
      style={{
        top: position.top,
        left: position.left,
        right: position.right,
        bottom: position.bottom,
        transform: rotate ? `rotate(${rotate})` : undefined
      }}
    >
      <Icon name={name} class="w-full h-full text-white filter drop-shadow-lg" />
    </div>
  ))}
</GradientHeroSection>

<style>
  @keyframes float {
    0%, 100% {
      transform: translateY(0) rotate(0);
      opacity: 0.2;
    }
    50% {
      transform: translateY(-20px) rotate(5deg);
      opacity: 0.3;
    }
  }

  @keyframes float-delayed {
    0%, 100% {
      transform: translateY(0) rotate(0);
      opacity: 0.15;
    }
    50% {
      transform: translateY(-15px) rotate(-5deg);
      opacity: 0.25;
    }
  }

  .animate-float {
    animation: float 6s ease-in-out infinite;
  }

  .animate-float-delayed {
    animation: float-delayed 8s ease-in-out infinite;
    animation-delay: -2s;
  }
  
  @keyframes float-arrow {
    0% { transform: translateY(0px); }
    50% { transform: translateY(10px); }
    100% { transform: translateY(0px); }
  }

  .arrow-animation {
    animation: float-arrow 2s ease-in-out infinite;
  }

  .arrow-animation:hover {
    animation-play-state: paused;
  }

  @media (prefers-reduced-motion: reduce) {
    .arrow-animation {
      animation: none;
    }
  }
</style>

<script define:vars={{ scrollTargetId }}>
  // Ajouter la fonctionnalité de scroll lors du clic
  const setupScrollArrow = () => {
    const arrowContainers = document.querySelectorAll('.flex.flex-col.items-center.group.cursor-pointer');
    
    arrowContainers.forEach(container => {
      // Récupérer l'ID cible depuis l'attribut data-target-id
      const targetId = container.getAttribute('data-target-id') || scrollTargetId;
      
      if (!targetId) return;
      
      container.addEventListener('click', () => {
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          const headerOffset = 100;
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

          window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth'
          });
        } else {
          const defaultScrollDistance = window.innerHeight * 0.8;
          const currentPosition = window.pageYOffset;
          window.scrollTo({
            top: currentPosition + defaultScrollDistance,
            behavior: 'smooth'
          });
        }
      });
    });
  };

  // Exécuter au chargement
  document.addEventListener('DOMContentLoaded', () => {
    setupScrollArrow();
  });
  document.addEventListener('astro:after-swap', () => {
    setupScrollArrow();
  });
</script>