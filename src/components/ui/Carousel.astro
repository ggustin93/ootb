---
import { Icon } from 'astro-icon/components';
import Image from '~/components/common/Image.astro';

interface Photo {
  src: string;
  alt: string;
  title: string;
}

interface Props {
  photos: Photo[];
}

const { photos } = Astro.props;
---

<div class="relative overflow-hidden rounded-2xl shadow-lg">
  <!-- Carousel container -->
  <div class="carousel-container relative">
    <!-- Images -->
    <div class="carousel-track flex transition-transform duration-500 ease-out">
      {photos.map((photo, index) => (
        <div class="carousel-slide min-w-full">
          <div class="relative aspect-[16/9] overflow-hidden">
            <Image
              src={photo.src}
              alt={photo.alt}
              class="w-full h-full object-cover"
              widths={[400, 800]}
              sizes="(max-width: 768px) 400px, 800px"
              aspectRatio="16:9"
              loading={index === 0 ? "eager" : "lazy"}
              decoding="async"
            />
            <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-4 text-white">
              <h3 class="text-lg md:text-xl font-semibold">{photo.title}</h3>
            </div>
          </div>
        </div>
      ))}
    </div>

    <!-- Navigation buttons -->
    <button
      class="carousel-prev absolute left-4 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white text-gray-800 p-2 rounded-full shadow-md z-10 transition-all duration-300 hover:scale-110"
      aria-label="Image précédente"
    >
      <Icon name="tabler:chevron-left" class="w-6 h-6" />
    </button>
    <button
      class="carousel-next absolute right-4 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white text-gray-800 p-2 rounded-full shadow-md z-10 transition-all duration-300 hover:scale-110"
      aria-label="Image suivante"
    >
      <Icon name="tabler:chevron-right" class="w-6 h-6" />
    </button>

    <!-- Indicators -->
    <div class="carousel-indicators absolute bottom-4 left-1/2 -translate-x-1/2 flex space-x-2 z-10">
      {photos.map((_, index) => (
        <button
          class="carousel-indicator w-2.5 h-2.5 rounded-full bg-white/50 hover:bg-white/80 transition-all duration-300"
          data-index={index}
          aria-label={`Aller à l'image ${index + 1}`}
        ></button>
      ))}
    </div>
  </div>
</div>

<script>
  class Carousel {
    container: HTMLElement;
    track: HTMLElement;
    slides: HTMLElement[];
    indicators: HTMLElement[];
    prevButton: HTMLElement;
    nextButton: HTMLElement;
    currentIndex: number = 0;
    slideCount: number;
    autoplayInterval: number | null = null;

    constructor(container: HTMLElement) {
      this.container = container;
      this.track = container.querySelector('.carousel-track') as HTMLElement;
      this.slides = Array.from(container.querySelectorAll('.carousel-slide')) as HTMLElement[];
      this.indicators = Array.from(container.querySelectorAll('.carousel-indicator')) as HTMLElement[];
      this.prevButton = container.querySelector('.carousel-prev') as HTMLElement;
      this.nextButton = container.querySelector('.carousel-next') as HTMLElement;
      this.slideCount = this.slides.length;

      this.init();
    }

    init() {
      // Set initial state
      this.updateIndicators();
      
      // Add event listeners
      this.prevButton.addEventListener('click', () => this.prev());
      this.nextButton.addEventListener('click', () => this.next());
      
      this.indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => this.goToSlide(index));
      });

      // Touch events for swipe
      let startX: number;
      let endX: number;
      
      this.container.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
      }, { passive: true });
      
      this.container.addEventListener('touchend', (e) => {
        endX = e.changedTouches[0].clientX;
        if (startX - endX > 50) {
          this.next();
        } else if (endX - startX > 50) {
          this.prev();
        }
      }, { passive: true });

      // Start autoplay
      this.startAutoplay();

      // Pause autoplay on hover
      this.container.addEventListener('mouseenter', () => this.stopAutoplay());
      this.container.addEventListener('mouseleave', () => this.startAutoplay());
      this.container.addEventListener('touchstart', () => this.stopAutoplay());
      this.container.addEventListener('touchend', () => this.startAutoplay());

      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (this.isInViewport()) {
          if (e.key === 'ArrowLeft') {
            this.prev();
          } else if (e.key === 'ArrowRight') {
            this.next();
          }
        }
      });

      // Preload adjacent images
      this.preloadAdjacentImages();
    }

    isInViewport() {
      const rect = this.container.getBoundingClientRect();
      return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
      );
    }

    preloadAdjacentImages() {
      // Preload next and previous images
      const preloadNext = (this.currentIndex + 1) % this.slideCount;
      const preloadPrev = (this.currentIndex - 1 + this.slideCount) % this.slideCount;
      
      const nextSlide = this.slides[preloadNext].querySelector('img');
      const prevSlide = this.slides[preloadPrev].querySelector('img');
      
      if (nextSlide && nextSlide.getAttribute('loading') === 'lazy') {
        nextSlide.setAttribute('loading', 'eager');
      }
      
      if (prevSlide && prevSlide.getAttribute('loading') === 'lazy') {
        prevSlide.setAttribute('loading', 'eager');
      }
    }

    startAutoplay() {
      this.stopAutoplay();
      this.autoplayInterval = window.setInterval(() => {
        this.next();
      }, 5000);
    }

    stopAutoplay() {
      if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);
        this.autoplayInterval = null;
      }
    }

    updateIndicators() {
      this.indicators.forEach((indicator, index) => {
        if (index === this.currentIndex) {
          indicator.classList.add('bg-white');
          indicator.classList.remove('bg-white/50');
        } else {
          indicator.classList.remove('bg-white');
          indicator.classList.add('bg-white/50');
        }
      });
    }

    goToSlide(index: number) {
      this.currentIndex = index;
      this.track.style.transform = `translateX(-${this.currentIndex * 100}%)`;
      this.updateIndicators();
      this.preloadAdjacentImages();
    }

    next() {
      this.currentIndex = (this.currentIndex + 1) % this.slideCount;
      this.goToSlide(this.currentIndex);
    }

    prev() {
      this.currentIndex = (this.currentIndex - 1 + this.slideCount) % this.slideCount;
      this.goToSlide(this.currentIndex);
    }
  }

  // Initialize all carousels on the page
  document.addEventListener('DOMContentLoaded', () => {
    const carouselContainers = document.querySelectorAll('.carousel-container');
    carouselContainers.forEach(container => {
      new Carousel(container as HTMLElement);
    });
  });
</script>

<style>
  .carousel-indicator.active {
    @apply bg-white scale-125;
  }
</style>
