---
/**
 * Composant ScrollDownArrow - Flèche de défilement élégante
 * 
 * Usage:
 * <ScrollDownArrow targetId="section-id" label="Découvrir" />
 */

 interface Props {
  /**
   * ID de l'élément cible vers lequel défiler
   */
  targetId: string;
  
  /**
   * Texte à afficher au-dessus de la flèche (optionnel)
   * @default "Découvrir"
   */
  label?: string;
  
  /**
   * Position verticale de la flèche (optionnel)
   * @default "bottom-[15%] md:bottom-[20%] lg:bottom-[25%]"
   */
  position?: string;
  
  /**
   * Classes CSS supplémentaires (optionnel)
   */
  class?: string;
  
  /**
   * Si true, masque la flèche sur mobile
   * @default true
   */
  hideOnMobile?: boolean;

  /**
   * Espacement vertical autour de la flèche (optionnel)
   * @default "my-4 md:my-6 lg:my-8"
   */
  spacing?: string;

  /**
   * Marge de sécurité pour éviter les chevauchements (optionnel)
   * @default "16"
   */
  safetyMargin?: number;
}

const { 
  targetId, 
  label = "Découvrir", 
  position = "bottom-[15%] md:bottom-[20%] lg:bottom-[25%]",
  class: className = "",
  hideOnMobile = true,
  spacing = "my-4 md:my-6 lg:my-8",
  safetyMargin = 16
} = Astro.props;
---

<div 
  id="scroll-down-arrow" 
  class:list={[
    "absolute left-1/2 transform -translate-x-1/2 z-40 cursor-pointer hover:scale-105 transition-all duration-300",
    hideOnMobile ? "hidden md:flex" : "flex",
    position,
    spacing,
    className
  ]}
  data-safety-margin={safetyMargin}
>
  <div class="flex flex-col items-center relative group">
    <!-- Texte avec son propre flou -->
    <p class="font-handwritten text-white text-2xl md:text-3xl mb-3 transform -rotate-3 relative drop-shadow-md group-hover:text-[--ootb-yellow] transition-colors duration-300">
      <span class="absolute inset-0 bg-white/10 backdrop-blur-md rounded-xl -z-10 scale-110 px-8"></span>
      {label}
    </p>
    
    <!-- La flèche sans flou -->
    <div class="arrow-container">
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        fill="none" 
        viewBox="0 0 24 24" 
        stroke-width="2.5" 
        stroke="currentColor" 
        class="w-8 h-8 md:w-10 md:h-10 text-white group-hover:text-[--ootb-yellow] transition-colors duration-300 drop-shadow-md"
      >
        <path 
          stroke-linecap="round" 
          stroke-linejoin="round" 
          d="M19.5 13.5L12 21m0 0l-7.5-7.5M12 21V3"
        />
      </svg>
    </div>
  </div>
</div>

<style>
  @keyframes float {
    0% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(15px);
    }
    100% {
      transform: translateY(0px);
    }
  }

  .arrow-container {
    animation: float 2s ease-in-out infinite;
  }

  .arrow-container:hover {
    animation-play-state: paused;
  }

  @media (prefers-reduced-motion: reduce) {
    .arrow-container {
      animation: none;
    }
  }
</style>

<script define:vars={{ targetId, safetyMargin }}>
  // Fonction de cleanup
  const cleanup = () => {
    const oldArrow = document.getElementById('scroll-down-arrow');
    if (oldArrow) {
      oldArrow.removeEventListener('click', handleClick);
      window.removeEventListener('resize', adjustPosition);
    }
  };

  // Fonction de scroll
  const handleClick = () => {
    const targetElement = document.getElementById(targetId);
    
    if (targetElement) {
      const headerOffset = 100;
      const elementPosition = targetElement.getBoundingClientRect().top;
      const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

      window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth'
      });
    } else {
      const defaultScrollDistance = window.innerHeight * 0.8;
      const currentPosition = window.pageYOffset;
      window.scrollTo({
        top: currentPosition + defaultScrollDistance,
        behavior: 'smooth'
      });
    }
  };

  // Fonction pour ajuster la position en fonction des éléments adjacents
  const adjustPosition = () => {
    const scrollArrow = document.getElementById('scroll-down-arrow');
    if (!scrollArrow) return;
    
    const arrowRect = scrollArrow.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const margin = safetyMargin || 16; // Marge de sécurité

    // Vérifier si la flèche est trop proche du bas de l'écran
    if (arrowRect.bottom > viewportHeight - margin) {
      const newBottomPosition = (viewportHeight - arrowRect.height - margin) / viewportHeight * 100;
      scrollArrow.style.bottom = `${newBottomPosition}%`;
    }

    // Vérifier les chevauchements avec d'autres éléments
    const otherElements = document.querySelectorAll('header, footer, [data-avoid-overlap="true"]');
    let needsAdjustment = false;
    
    otherElements.forEach(element => {
      if (element === scrollArrow) return;
      
      const elementRect = element.getBoundingClientRect();
      
      // Vérifier si les rectangles se chevauchent
      if (!(arrowRect.right < elementRect.left || 
            arrowRect.left > elementRect.right || 
            arrowRect.bottom < elementRect.top || 
            arrowRect.top > elementRect.bottom)) {
        needsAdjustment = true;
      }
    });
    
    if (needsAdjustment) {
      // Ajuster la position verticale pour éviter le chevauchement
      const newBottomPosition = Math.max(10, (arrowRect.bottom / viewportHeight * 100) + 5);
      scrollArrow.style.bottom = `${newBottomPosition}%`;
    }
  };

  // Cleanup avant initialisation pour éviter les doublons
  cleanup();

  // Initialisation avec gestion du lifecycle Astro
  const init = () => {
    const scrollArrow = document.getElementById('scroll-down-arrow');
    if (scrollArrow) {
      scrollArrow.addEventListener('click', handleClick);
      window.addEventListener('resize', adjustPosition);
      // Ajuster la position initiale après un court délai pour s'assurer que la page est complètement chargée
      setTimeout(adjustPosition, 150);
    }
  };

  // Initialisation au chargement initial
  document.addEventListener('DOMContentLoaded', init);

  // Réinitialisation lors des navigations View Transitions
  document.addEventListener('astro:after-swap', init);

  // Cleanup avant les transitions de page
  document.addEventListener('astro:before-swap', cleanup);

  // Cleanup lors du unmount
  document.addEventListener('astro:unmount', cleanup);
</script>