// Script de g√©n√©ration des fiches p√©dagogiques depuis NocoDB
// Ce script est ex√©cut√© uniquement au moment du build

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import { Api } from 'nocodb-sdk';
import slugify from 'slugify';

// Charger les variables d'environnement
dotenv.config();

// Obtenir le chemin du r√©pertoire actuel
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, '../..');

// D√©terminer si nous sommes en mode production
const IS_NETLIFY = process.env.NETLIFY === 'true';
const FORCE_PRODUCTION = process.env.FORCE_PRODUCTION === 'true';
const NODE_ENV_PRODUCTION = process.env.NODE_ENV === 'production';

// Si nous sommes sur Netlify ou si le mode production est forc√© ou si NODE_ENV est production
const IS_PRODUCTION = IS_NETLIFY || FORCE_PRODUCTION || NODE_ENV_PRODUCTION;

console.log(`üîß Environnement de build des fiches p√©dagogiques:`);
console.log(`   - Netlify: ${IS_NETLIFY ? 'Oui' : 'Non'}`);
console.log(`   - Force Production: ${FORCE_PRODUCTION ? 'Oui' : 'Non'}`);
console.log(`   - NODE_ENV Production: ${NODE_ENV_PRODUCTION ? 'Oui' : 'Non'}`);
console.log(`   - Mode Production: ${IS_PRODUCTION ? 'Oui' : 'Non'}`);

// Configuration de NocoDB
const NOCODB_BASE_URL = process.env.NOCODB_BASE_URL || 'https://app.nocodb.com';
const NOCODB_API_TOKEN = process.env.NOCODB_API_TOKEN;

// IDs NocoDB pour la table des fiches p√©dagogiques (√† remplacer par vos valeurs r√©elles)
const NOCODB_ORG_ID = process.env.NOCODB_ORG_ID || 'noco';
const NOCODB_PROJECT_ID = process.env.NOCODB_PROJECT_ID || 'pzafxqd4lr77r0v';
const NOCODB_BASE_ID = process.env.NOCODB_BASE_ID || 'mur92i1x276ldbg';
const NOCODB_TABLE_ID = process.env.NOCODB_TABLE_ID || 'vwp6ybxaurqxfimt';

// Chemin de destination pour les fichiers MDX
const FICHES_DIR = path.join(ROOT_DIR, 'src', 'content', 'post', '5_FICHES');

// R√©pertoire pour sauvegarder les donn√©es brutes
const RAW_DATA_DIR = path.join(ROOT_DIR, 'data', 'raw');

// Fichier o√π seront stock√©es les donn√©es brutes
const RAW_DATA_FILENAME = 'fiches_pedagogiques_raw.json';
const RAW_DATA_PATH = path.join(RAW_DATA_DIR, RAW_DATA_FILENAME);

// Ann√©e d'√©dition (√† modifier chaque ann√©e)
const EDITION_YEAR = '2024';

/**
 * Nettoie le r√©pertoire des fiches p√©dagogiques
 */
function cleanFichesDirectory() {
  try {
    if (fs.existsSync(FICHES_DIR)) {
      // Lire tous les fichiers MDX dans le r√©pertoire (sauf README.md)
      const files = fs.readdirSync(FICHES_DIR)
        .filter(file => file.endsWith('.mdx') && file !== 'README.md');
      
      console.log(`üßπ Nettoyage du r√©pertoire des fiches: ${files.length} fichiers √† supprimer...`);
      
      // Supprimer chaque fichier
      files.forEach(file => {
        const filePath = path.join(FICHES_DIR, file);
        fs.unlinkSync(filePath);
      });
      
      console.log(`‚úÖ R√©pertoire nettoy√© avec succ√®s.`);
    } else {
      // Si le r√©pertoire n'existe pas, le cr√©er
      fs.mkdirSync(FICHES_DIR, { recursive: true });
      console.log(`üìÅ R√©pertoire cr√©√©: ${FICHES_DIR}`);
    }
  } catch (error) {
    console.error(`‚ùå Erreur lors du nettoyage du r√©pertoire:`, error);
  }
}

/**
 * Sauvegarde les donn√©es brutes dans un fichier JSON
 */
function saveRawData(data, filename) {
  try {
    // Cr√©ation du r√©pertoire s'il n'existe pas
    if (!fs.existsSync(RAW_DATA_DIR)) {
      fs.mkdirSync(RAW_DATA_DIR, { recursive: true });
      console.log(`üìÅ R√©pertoire cr√©√©: ${RAW_DATA_DIR}`);
    }
    
    const filePath = path.join(RAW_DATA_DIR, filename);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    console.log(`‚úÖ Donn√©es brutes sauvegard√©es dans ${filePath}`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de la sauvegarde des donn√©es brutes:`, error);
  }
}

/**
 * V√©rifie si les donn√©es ont chang√© par rapport aux donn√©es pr√©c√©demment sauvegard√©es
 * @param {Array} newData - Les nouvelles donn√©es r√©cup√©r√©es de l'API
 * @returns {boolean} - True si les donn√©es ont chang√©, false sinon
 */
function checkIfDataChanged(newData) {
  try {
    // V√©rifier si le fichier de donn√©es existe
    if (!fs.existsSync(RAW_DATA_PATH)) {
      console.log(`üìù Aucun fichier de donn√©es pr√©c√©dent trouv√©. G√©n√©ration requise.`);
      return true;
    }
    
    // Lire les anciennes donn√©es
    const oldDataRaw = fs.readFileSync(RAW_DATA_PATH, 'utf8');
    const oldData = JSON.parse(oldDataRaw);
    
    // Comparaison simple par nombre d'√©l√©ments
    if (!oldData.list || oldData.list.length !== newData.length) {
      console.log(`üìä Diff√©rence de nombre d'√©l√©ments d√©tect√©e (${oldData.list ? oldData.list.length : 0} vs ${newData.length}). G√©n√©ration requise.`);
      return true;
    }
    
    // V√©rifier si les identifiants et dates de mise √† jour sont identiques
    const newDataMap = new Map(newData.map(item => [item.Id, JSON.stringify(item)]));
    let hasChanges = false;
    
    for (const oldItem of oldData.list) {
      if (!oldItem.Id) continue;
      
      // Si l'√©l√©ment n'existe plus ou a √©t√© modifi√©
      if (!newDataMap.has(oldItem.Id) || newDataMap.get(oldItem.Id) !== JSON.stringify(oldItem)) {
        hasChanges = true;
        break;
      }
    }
    
    if (hasChanges) {
      console.log(`üîÑ Modifications d√©tect√©es dans les donn√©es. G√©n√©ration requise.`);
    } else {
      console.log(`‚úÖ Aucune modification d√©tect√©e dans les donn√©es. G√©n√©ration non n√©cessaire.`);
    }
    
    return hasChanges;
  } catch (error) {
    console.error(`‚ùå Erreur lors de la v√©rification des donn√©es:`, error);
    // En cas d'erreur, on g√©n√®re par s√©curit√©
    return true;
  }
}

/**
 * Initialise l'API NocoDB
 */
function initNocoDBApi() {
  console.log('Initialisation de l\'API NocoDB avec le token:', NOCODB_API_TOKEN ? 'Token pr√©sent' : 'Token manquant');
  
  return new Api({
    baseURL: NOCODB_BASE_URL,
    headers: {
      "xc-token": NOCODB_API_TOKEN
    }
  });
}

/**
 * R√©cup√®re les fiches p√©dagogiques depuis NocoDB
 */
async function fetchFichesPedagogiques() {
  try {
    console.log('üì• R√©cup√©ration des fiches p√©dagogiques depuis NocoDB...');
    
    const api = initNocoDBApi();
    
    const response = await api.dbViewRow.list(
      NOCODB_ORG_ID,
      NOCODB_PROJECT_ID,
      NOCODB_BASE_ID,
      NOCODB_TABLE_ID, {
      "offset": 0,
      "limit": 100, // Augmenter si n√©cessaire
      "where": ""
    });
    
    console.log(`‚úÖ ${response.list.length} fiches p√©dagogiques r√©cup√©r√©es.`);
    
    return response;
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des fiches p√©dagogiques:', error);
    return { list: [] };
  }
}

/**
 * Convertit les fiches au format MDX
 */
function convertFichesToMDX(fiches) {
  console.log('üîÑ Conversion des fiches au format MDX...');
  
  return fiches.map((fiche, index) => {
    try {
      // Cr√©ation du slug √† partir du titre avec un ID unique pour √©viter les collisions
      const baseSlug = slugify(fiche.Title || 'fiche-pedagogique', {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g
      });
      
      // R√©cup√©rer l'√©dition depuis les donn√©es ou utiliser l'ann√©e par d√©faut
      const edition = fiche.Edition || EDITION_YEAR;
      
      // Ajouter l'√©dition et l'ID pour garantir l'unicit√©
      const slug = fiche.Id ? 
        `${edition}-${baseSlug}-${fiche.Id}` : 
        `${edition}-${baseSlug}-${index + 1}`;
      
      // Construction de la date de publication en fonction de l'ann√©e d'√©dition avec date al√©atoire
      const publishYear = parseInt(edition) || new Date().getFullYear();
      
      // G√©n√©ration d'une date al√©atoire dans l'ann√©e d'√©dition
      const randomMonth = Math.floor(Math.random() * 12) + 1; // Mois entre 1 et 12
      const maxDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][randomMonth - 1]; // Jours par mois
      const randomDay = Math.floor(Math.random() * maxDay) + 1; // Jour entre 1 et max pour le mois
      
      // Format de la date avec padding pour mois et jours √† 2 chiffres
      const paddedMonth = randomMonth.toString().padStart(2, '0');
      const paddedDay = randomDay.toString().padStart(2, '0');
      
      // Construction de la date ISO avec heure al√©atoire 
      const randomHour = Math.floor(Math.random() * 24);
      const randomMinute = Math.floor(Math.random() * 60);
      const randomSecond = Math.floor(Math.random() * 60);
      
      const publishDate = `${publishYear}-${paddedMonth}-${paddedDay}T${randomHour.toString().padStart(2, '0')}:${randomMinute.toString().padStart(2, '0')}:${randomSecond.toString().padStart(2, '0')}.001Z`;
      
      // Construction des tags (incluant la section et le type d'enseignement)
      const tags = [];
      
      // Ajouter l'√©dition comme tag
      if (fiche.Edition) {
        tags.push(fiche.Edition);
      }
      
      // Ajouter les th√®mes aux tags
      if (fiche.Th√®mes) {
        try {
          const themes = JSON.parse(fiche.Th√®mes);
          if (Array.isArray(themes)) {
            themes.forEach(theme => {
              // Ignorer les th√®mes au format "th√®me X" o√π X est un chiffre
              if (!(/^th√®me \d+$/i.test(theme))) {
                tags.push(theme.toLowerCase());
              }
            });
          } else {
            // Ignorer les th√®mes au format "th√®me X" o√π X est un chiffre
            if (!(/^th√®me \d+$/i.test(themes))) {
              tags.push(themes.toLowerCase());
            }
          }
        } catch {
          // Si ce n'est pas un JSON valide, l'ajouter tel quel si ce n'est pas "th√®me X"
          if (!(/^th√®me \d+$/i.test(fiche.Th√®mes))) {
            tags.push(fiche.Th√®mes.toLowerCase());
          }
        }
      }
      
      // Traiter "Type enseignement" qui peut √™tre au format JSON string
      if (fiche["Type enseignement"]) {
        try {
          const typeEnseignement = JSON.parse(fiche["Type enseignement"]);
          if (Array.isArray(typeEnseignement)) {
            typeEnseignement.forEach(type => tags.push(type.toLowerCase()));
          } else {
            tags.push(typeEnseignement.toLowerCase());
          }
        } catch {
          // Si ce n'est pas un JSON valide, l'ajouter tel quel
          tags.push(fiche["Type enseignement"].toLowerCase());
        }
      }
      
      // Traiter "Section" qui peut √™tre au format JSON string
      if (fiche.Section) {
        try {
          const section = JSON.parse(fiche.Section);
          if (Array.isArray(section)) {
            section.forEach(s => tags.push(s.toLowerCase()));
          } else {
            tags.push(section.toLowerCase());
          }
        } catch {
          // Si ce n'est pas un JSON valide, l'ajouter tel quel
          tags.push(fiche.Section.toLowerCase());
        }
      }
      
      // Construire les objectifs sous forme de tableau
      const objectifs = fiche.Objectifs 
        ? fiche.Objectifs.split('\n').filter(item => item.trim() !== '')
        : [];
      
      // Construire les comp√©tences sous forme de tableau
      const competences = fiche.Competences 
        ? fiche.Competences.split('\n').filter(item => item.trim() !== '')
        : [];
      
      // Construire les r√©f√©rences sous forme de tableau d'objets
      const references = [];
      
      // Ajouter les liens textuels
      if (fiche.Liens) {
        const liens = fiche.Liens.split('\n').filter(item => item.trim() !== '');
        liens.forEach(lien => {
          // Extraire les URLs si pr√©sentes
          const urlMatch = lien.match(/(https?:\/\/[^\s]+)/g);
          if (urlMatch) {
            references.push({
              type: 'site',
              description: lien.trim(),
              url: urlMatch[0]
            });
          } else {
            references.push({
              type: 'document',
              description: lien.trim()
            });
          }
        });
      }
      
      // Ajouter les liens vid√©o
      if (fiche.LiensVIDEO) {
        references.push({
          type: 'video',
          description: 'Vid√©o de pr√©sentation',
          url: fiche.LiensVIDEO.trim()
        });
      }
      
      // D√©terminer le type d'enseignement √† partir du champ "Type enseignement"
      let typeEnseignement = 'Ordinaire';
      if (fiche["Type enseignement"]) {
        try {
          const typeArray = JSON.parse(fiche["Type enseignement"]);
          typeEnseignement = Array.isArray(typeArray) ? typeArray[0] : typeArray;
        } catch {
          typeEnseignement = fiche["Type enseignement"];
        }
      }
      
      // D√©terminer la section √† partir du champ "Section"
      let section = 'Primaire';
      if (fiche.Section) {
        try {
          const sectionArray = JSON.parse(fiche.Section);
          section = Array.isArray(sectionArray) ? sectionArray[0] : sectionArray;
        } catch {
          section = fiche.Section;
        }
      }
      
      // Construction du contenu MDX
      const frontmatter = {
        published: true,
        title: fiche.Title || 'Fiche p√©dagogique',
        description: fiche.Description ? fiche.Description.substring(0, 160) : '',
        publishDate: publishDate,
        category: 'fiche',
        image: null,
        tags,
        pedagogicalSheet: {
          enseignement: typeEnseignement,
          section: section,
          responsable: {
            prenom: fiche.Pr√©nom || '',
            nom: fiche.Nom || '',
            email: fiche.Email || ''
          },
          description: fiche.Description || '',
          destinataire: fiche.Destinataire || '',
          objectifs,
          competences,
          references,
          declinaisons: fiche.D√©clinaisons || '',
          conseils: fiche.Conseils || ''
        }
      };
      
      // Construction du contenu complet
      const mdxContent = `---
${Object.entries(frontmatter).map(([key, value]) => {
  if (typeof value === 'object') {
    return `${key}: ${JSON.stringify(value, null, 2)}`;
  } else if (key === 'published') {
    // G√©rer sp√©cifiquement le bool√©en published
    return `${key}: ${value}`;
  } else if (key === 'publishDate') {
    // G√©rer sp√©cifiquement la date
    return `${key}: ${value}`;
  } else if (typeof value === 'string' && (value.includes('\n') || value.includes(':'))) {
    // Pour les cha√Ænes multilignes ou contenant des caract√®res sp√©ciaux, utiliser le format bloc
    return `${key}: >-\n  ${value.replace(/\n/g, '\n  ')}`;
  } else {
    // Pour les cha√Ænes simples, les mettre entre guillemets pour √©viter les probl√®mes
    return `${key}: "${value.toString().replace(/"/g, '\\"')}"`;
  }
}).join('\n')}
---

`;
      
      return {
        slug,
        content: mdxContent
      };
    } catch (error) {
      console.error(`‚ùå Erreur lors de la conversion de la fiche "${fiche.Title || 'sans titre'}":`, error);
      return null;
    }
  }).filter(Boolean); // Filtrer les fiches nulles en cas d'erreur
}

/**
 * Sauvegarde les fiches en fichiers MDX
 */
async function saveFichesToFiles(fiches) {
  console.log(`üíæ Sauvegarde de ${fiches.length} fiches p√©dagogiques...`);
  
  // Cr√©ation du r√©pertoire des fiches s'il n'existe pas
  if (!fs.existsSync(FICHES_DIR)) {
    fs.mkdirSync(FICHES_DIR, { recursive: true });
    console.log(`üìÅ R√©pertoire cr√©√©: ${FICHES_DIR}`);
  }
  
  for (const fiche of fiches) {
    const filePath = path.join(FICHES_DIR, `${fiche.slug}.mdx`);
    
    try {
      fs.writeFileSync(filePath, fiche.content, 'utf8');
      console.log(`‚úÖ Fiche sauvegard√©e: ${filePath}`);
    } catch (error) {
      console.error(`‚ùå Erreur lors de la sauvegarde de la fiche ${fiche.slug}:`, error);
    }
  }
}

/**
 * Fonction principale
 */
async function main() {
  console.log('üöÄ D√©marrage de la g√©n√©ration des fiches p√©dagogiques...');
  
  try {
    // 1. R√©cup√©ration des fiches depuis NocoDB
    const response = await fetchFichesPedagogiques();
    const fiches = response.list || [];
    
    if (fiches.length === 0) {
      console.log('‚ö†Ô∏è Aucune fiche p√©dagogique trouv√©e, fin du processus.');
      return;
    }
    
    // 2. V√©rifier si les donn√©es ont chang√©
    const dataChanged = checkIfDataChanged(fiches);
    
    // Sauvegarder les nouvelles donn√©es brutes dans tous les cas pour comparaison future
    saveRawData(response, RAW_DATA_FILENAME);
    
    // N'ex√©cuter les √©tapes suivantes que si les donn√©es ont chang√©
    if (dataChanged) {
      console.log('üîÑ Des modifications ont √©t√© d√©tect√©es, mise √† jour des fiches en cours...');
      
      // 3. Nettoyer le r√©pertoire des fiches
      cleanFichesDirectory();
      
      // 4. Conversion des fiches au format MDX
      const fichesConverties = convertFichesToMDX(fiches);
      
      // 5. Sauvegarde des fiches en fichiers MDX
      await saveFichesToFiles(fichesConverties);
      
      console.log('‚ú® G√©n√©ration des fiches p√©dagogiques termin√©e avec succ√®s!');
    } else {
      console.log('üí§ Aucune modification d√©tect√©e, aucune action n√©cessaire.');
    }
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration des fiches p√©dagogiques:', error);
    process.exit(1);
  }
}

// Ex√©cution du script
main().catch(error => {
  console.error('‚ùå Erreur fatale:', error);
  process.exit(1);
}); 