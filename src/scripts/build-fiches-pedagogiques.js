// Script de g√©n√©ration des fiches p√©dagogiques depuis NocoDB
// Ce script est ex√©cut√© uniquement au moment du build

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import { Api } from 'nocodb-sdk';
import slugify from 'slugify';

// Charger les variables d'environnement
dotenv.config();

// Obtenir le chemin du r√©pertoire actuel
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, '../..');

// D√©terminer si nous sommes en mode production
const IS_NETLIFY = process.env.NETLIFY === 'true';
const FORCE_PRODUCTION = process.env.FORCE_PRODUCTION === 'true';
const NODE_ENV_PRODUCTION = process.env.NODE_ENV === 'production';

// Si nous sommes sur Netlify ou si le mode production est forc√© ou si NODE_ENV est production
const IS_PRODUCTION = IS_NETLIFY || FORCE_PRODUCTION || NODE_ENV_PRODUCTION;

console.log(`üîß Environnement de build des fiches p√©dagogiques:`);
console.log(`   - Netlify: ${IS_NETLIFY ? 'Oui' : 'Non'}`);
console.log(`   - Force Production: ${FORCE_PRODUCTION ? 'Oui' : 'Non'}`);
console.log(`   - NODE_ENV Production: ${NODE_ENV_PRODUCTION ? 'Oui' : 'Non'}`);
console.log(`   - Mode Production: ${IS_PRODUCTION ? 'Oui' : 'Non'}`);

// Configuration de NocoDB
const NOCODB_BASE_URL = process.env.NOCODB_BASE_URL || 'https://app.nocodb.com';
const NOCODB_API_TOKEN = process.env.NOCODB_API_TOKEN;

// IDs NocoDB pour la table des fiches p√©dagogiques (√† remplacer par vos valeurs r√©elles)
const NOCODB_ORG_ID = process.env.NOCODB_ORG_ID || 'noco';
const NOCODB_PROJECT_ID = process.env.NOCODB_PROJECT_ID || 'pzafxqd4lr77r0v';
const NOCODB_BASE_ID = process.env.NOCODB_BASE_ID || 'mur92i1x276ldbg';
const NOCODB_TABLE_ID = process.env.NOCODB_TABLE_ID || 'vwp6ybxaurqxfimt';

// Chemin de destination pour les fichiers MDX
const FICHES_DIR = path.join(ROOT_DIR, 'src', 'content', 'post', '5_FICHES');

// R√©pertoire pour sauvegarder les donn√©es brutes
const RAW_DATA_DIR = path.join(ROOT_DIR, 'data', 'raw');

// Fichier o√π seront stock√©es les donn√©es brutes
const RAW_DATA_FILENAME = 'fiches_pedagogiques_raw.json';
const RAW_DATA_PATH = path.join(RAW_DATA_DIR, RAW_DATA_FILENAME);

// Ann√©e d'√©dition (√† modifier chaque ann√©e)
const EDITION_YEAR = '2024';

/**
 * Sauvegarde les donn√©es brutes dans un fichier JSON
 */
function saveRawData(data, filename) {
  try {
    // Cr√©ation du r√©pertoire s'il n'existe pas
    if (!fs.existsSync(RAW_DATA_DIR)) {
      fs.mkdirSync(RAW_DATA_DIR, { recursive: true });
      console.log(`üìÅ R√©pertoire cr√©√©: ${RAW_DATA_DIR}`);
    }
    
    const filePath = path.join(RAW_DATA_DIR, filename);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    console.log(`‚úÖ Donn√©es brutes sauvegard√©es dans ${filePath}`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de la sauvegarde des donn√©es brutes:`, error);
  }
}

/**
 * V√©rifie si les donn√©es ont chang√© par rapport aux donn√©es pr√©c√©demment sauvegard√©es
 * @param {Array} newData - Les nouvelles donn√©es r√©cup√©r√©es de l'API
 * @returns {Object} - { hasChanges, changedItems, removedItems, addedItems }
 */
function checkIfDataChanged(newData) {
  try {
    // V√©rifier si le fichier de donn√©es existe
    if (!fs.existsSync(RAW_DATA_PATH)) {
      console.log(`üìù Aucun fichier de donn√©es pr√©c√©dent trouv√©. G√©n√©ration compl√®te requise.`);
      return { 
        hasChanges: true, 
        changedItems: newData, 
        removedItems: [], 
        addedItems: newData 
      };
    }
    
    // Lire les anciennes donn√©es
    const oldDataRaw = fs.readFileSync(RAW_DATA_PATH, 'utf8');
    const oldData = JSON.parse(oldDataRaw);
    const oldItems = oldData.list || [];
    
    // Comparaison simple par nombre d'√©l√©ments
    if (oldItems.length !== newData.length) {
      console.log(`üìä Diff√©rence de nombre d'√©l√©ments d√©tect√©e (${oldItems.length} vs ${newData.length}).`);
    }
    
    // Cr√©er des maps pour faciliter la comparaison
    const oldItemsMap = new Map(oldItems.map(item => [item.Id, item]));
    const newItemsMap = new Map(newData.map(item => [item.Id, item]));
    
    // Identifier les √©l√©ments modifi√©s, supprim√©s et ajout√©s
    const changedItems = [];
    const removedItems = [];
    const addedItems = [];
    
    // V√©rifier les √©l√©ments modifi√©s et supprim√©s
    for (const oldItem of oldItems) {
      if (!oldItem.Id) continue;
      
      if (!newItemsMap.has(oldItem.Id)) {
        // √âl√©ment supprim√©
        removedItems.push(oldItem);
      } else {
        // V√©rifier si l'√©l√©ment a √©t√© modifi√©
        const newItem = newItemsMap.get(oldItem.Id);
        if (JSON.stringify(oldItem) !== JSON.stringify(newItem)) {
          changedItems.push(newItem);
        }
      }
    }
    
    // V√©rifier les √©l√©ments ajout√©s
    for (const newItem of newData) {
      if (!newItem.Id) continue;
      
      if (!oldItemsMap.has(newItem.Id)) {
        addedItems.push(newItem);
      }
    }
    
    const hasChanges = changedItems.length > 0 || removedItems.length > 0 || addedItems.length > 0;
    
    if (hasChanges) {
      console.log(`üîÑ Modifications d√©tect√©es:`);
      console.log(`   - ${changedItems.length} fiches modifi√©es`);
      console.log(`   - ${addedItems.length} fiches ajout√©es`);
      console.log(`   - ${removedItems.length} fiches supprim√©es`);
    } else {
      console.log(`‚úÖ Aucune modification d√©tect√©e dans les donn√©es. G√©n√©ration non n√©cessaire.`);
    }
    
    return { hasChanges, changedItems, removedItems, addedItems };
  } catch (error) {
    console.error(`‚ùå Erreur lors de la v√©rification des donn√©es:`, error);
    // En cas d'erreur, on g√©n√®re tout par s√©curit√©
    return { 
      hasChanges: true, 
      changedItems: newData, 
      removedItems: [], 
      addedItems: newData 
    };
  }
}

/**
 * Initialise l'API NocoDB
 */
function initNocoDBApi() {
  console.log('Initialisation de l\'API NocoDB avec le token:', NOCODB_API_TOKEN ? 'Token pr√©sent' : 'Token manquant');
  
  return new Api({
    baseURL: NOCODB_BASE_URL,
    headers: {
      "xc-token": NOCODB_API_TOKEN
    }
  });
}

/**
 * R√©cup√®re les fiches p√©dagogiques depuis NocoDB
 */
async function fetchFichesPedagogiques() {
  try {
    console.log('üì• R√©cup√©ration des fiches p√©dagogiques depuis NocoDB...');
    
    const api = initNocoDBApi();
    
    const response = await api.dbViewRow.list(
      NOCODB_ORG_ID,
      NOCODB_PROJECT_ID,
      NOCODB_BASE_ID,
      NOCODB_TABLE_ID, {
      "offset": 0,
      "limit": 100, // Augmenter si n√©cessaire
      "where": ""
    });
    
    console.log(`‚úÖ ${response.list.length} fiches p√©dagogiques r√©cup√©r√©es.`);
    
    return response;
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des fiches p√©dagogiques:', error);
    return { list: [] };
  }
}

/**
 * Convertit les fiches au format MDX
 */
function convertFichesToMDX(fiches) {
  console.log('üîÑ Conversion des fiches au format MDX...');
  
  return fiches.map((fiche, index) => {
    try {
      // Cr√©ation du slug √† partir du titre avec un ID unique pour √©viter les collisions
      const baseSlug = slugify(fiche.Title || 'fiche-pedagogique', {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g
      });
      
      // R√©cup√©rer l'√©dition depuis les donn√©es ou utiliser l'ann√©e par d√©faut
      const edition = fiche.Edition || EDITION_YEAR;
      
      // Ajouter l'√©dition et l'ID pour garantir l'unicit√©
      const slug = fiche.Id ? 
        `${edition}-${baseSlug}-${fiche.Id}` : 
        `${edition}-${baseSlug}-${index + 1}`;
      
      // D√©terminer la date de publication en fonction de l'√©dition
      let publishDate;
      
      // Si l'√©dition est 2025 ou non d√©finie/√©gale √† l'ann√©e courante, utiliser la date courante
      if (parseInt(edition) >= 2025 || !fiche.Edition) {
        // Utiliser la date actuelle ou la date de cr√©ation de la fiche si disponible
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        
        publishDate = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.001Z`;
        
        console.log(`üìÖ Fiche "${fiche.Title || 'sans titre'}" (√©dition ${edition}): date courante utilis√©e: ${publishDate}`);
      } else {
        // Pour les √©ditions 2024 et ant√©rieures, conserver le syst√®me de date al√©atoire
        const publishYear = parseInt(edition) || new Date().getFullYear();
        
        // G√©n√©ration d'une date al√©atoire dans l'ann√©e d'√©dition
        const randomMonth = Math.floor(Math.random() * 12) + 1; // Mois entre 1 et 12
        const maxDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][randomMonth - 1]; // Jours par mois
        const randomDay = Math.floor(Math.random() * maxDay) + 1; // Jour entre 1 et max pour le mois
        
        // Format de la date avec padding pour mois et jours √† 2 chiffres
        const paddedMonth = randomMonth.toString().padStart(2, '0');
        const paddedDay = randomDay.toString().padStart(2, '0');
        
        // Construction de la date ISO avec heure al√©atoire 
        const randomHour = Math.floor(Math.random() * 24);
        const randomMinute = Math.floor(Math.random() * 60);
        const randomSecond = Math.floor(Math.random() * 60);
        
        publishDate = `${publishYear}-${paddedMonth}-${paddedDay}T${randomHour.toString().padStart(2, '0')}:${randomMinute.toString().padStart(2, '0')}:${randomSecond.toString().padStart(2, '0')}.001Z`;
        
        console.log(`üìÖ Fiche "${fiche.Title || 'sans titre'}" (√©dition ${edition}): date al√©atoire g√©n√©r√©e: ${publishDate}`);
      }
      
      // Construction des tags (incluant la section et le type d'enseignement)
      const tags = [];
      
      // Ajouter l'√©dition comme tag
      if (fiche.Edition) {
        tags.push(fiche.Edition);
      }
      
      // Ajouter les th√®mes aux tags
      if (fiche.Th√®mes) {
        try {
          // V√©rifier si le th√®me est au format JSON
          const themes = JSON.parse(fiche.Th√®mes);
          
          // Fonction pour v√©rifier si un th√®me doit √™tre ignor√© (format "th√®me X" o√π X est un chiffre)
          const shouldIgnoreTheme = (theme) => /^th√®me \d+$/i.test(theme);
          
          if (Array.isArray(themes)) {
            // Si c'est un tableau de th√®mes, traiter chaque th√®me
            themes.forEach(theme => {
              if (!shouldIgnoreTheme(theme)) {
                console.log(`üè∑Ô∏è Ajout du th√®me "${theme}" aux tags pour la fiche "${fiche.Title || 'sans titre'}"`);
                tags.push(theme.toLowerCase());
              } else {
                console.log(`‚è≠Ô∏è Ignor√© le th√®me "${theme}" (format 'th√®me X') pour la fiche "${fiche.Title || 'sans titre'}"`);
              }
            });
          } else if (typeof themes === 'string') {
            // Si c'est une seule cha√Æne de caract√®res
            if (!shouldIgnoreTheme(themes)) {
              console.log(`üè∑Ô∏è Ajout du th√®me "${themes}" aux tags pour la fiche "${fiche.Title || 'sans titre'}"`);
              tags.push(themes.toLowerCase());
            } else {
              console.log(`‚è≠Ô∏è Ignor√© le th√®me "${themes}" (format 'th√®me X') pour la fiche "${fiche.Title || 'sans titre'}"`);
            }
          }
        } catch {
          // Si ce n'est pas un JSON valide, traiter comme une cha√Æne simple
          if (!/^th√®me \d+$/i.test(fiche.Th√®mes)) {
            console.log(`üè∑Ô∏è Ajout du th√®me "${fiche.Th√®mes}" (format non-JSON) aux tags pour la fiche "${fiche.Title || 'sans titre'}"`);
            tags.push(fiche.Th√®mes.toLowerCase());
          } else {
            console.log(`‚è≠Ô∏è Ignor√© le th√®me "${fiche.Th√®mes}" (format 'th√®me X') pour la fiche "${fiche.Title || 'sans titre'}"`);
          }
        }
      }
      
      // Construire les objectifs sous forme de tableau
      const objectifs = fiche.Objectifs 
        ? fiche.Objectifs.split('\n').filter(item => item.trim() !== '')
        : [];
      
      // Construire les comp√©tences sous forme de tableau
      const competences = fiche.Competences 
        ? fiche.Competences.split('\n').filter(item => item.trim() !== '')
        : [];
      
      // Construire les r√©f√©rences sous forme de tableau d'objets
      const references = [];
      
      // Ajouter les liens textuels
      if (fiche.Liens) {
        const liens = fiche.Liens.split('\n').filter(item => item.trim() !== '');
        liens.forEach(lien => {
          // Extraire les URLs si pr√©sentes
          const urlMatch = lien.match(/(https?:\/\/[^\s]+)/g);
          if (urlMatch) {
            references.push({
              type: 'site',
              description: lien.trim(),
              url: urlMatch[0]
            });
          } else {
            references.push({
              type: 'document',
              description: lien.trim()
            });
          }
        });
      }
      
      // Ajouter les liens vid√©o
      if (fiche.LiensVIDEO) {
        references.push({
          type: 'video',
          description: 'Vid√©o de pr√©sentation',
          url: fiche.LiensVIDEO.trim()
        });
      }
      
      // D√©terminer le type d'enseignement √† partir du champ "Type enseignement"
      let typeEnseignement = 'Ordinaire';
      if (fiche["Type enseignement"]) {
        try {
          const typeArray = JSON.parse(fiche["Type enseignement"]);
          typeEnseignement = Array.isArray(typeArray) ? typeArray[0] : typeArray;
        } catch {
          typeEnseignement = fiche["Type enseignement"];
        }
      }
      
      // D√©terminer la section √† partir du champ "Section"
      let section = 'Primaire';
      if (fiche.Section) {
        try {
          const sectionArray = JSON.parse(fiche.Section);
          section = Array.isArray(sectionArray) ? sectionArray[0] : sectionArray;
        } catch {
          section = fiche.Section;
        }
      }
      
      // Construction du contenu MDX
      const frontmatter = {
        published: true,
        title: fiche.Title || 'Fiche p√©dagogique',
        description: fiche.Description ? fiche.Description.substring(0, 160) : '',
        publishDate: publishDate,
        category: 'fiche',
        image: null,
        tags,
        pedagogicalSheet: {
          enseignement: typeEnseignement,
          section: section,
          responsable: {
            prenom: fiche.Pr√©nom || '',
            nom: fiche.Nom || '',
            email: fiche.Email || ''
          },
          description: fiche.Description || '',
          destinataire: fiche.Destinataire || '',
          objectifs,
          competences,
          references,
          declinaisons: fiche.D√©clinaisons || '',
          conseils: fiche.Conseils || ''
        }
      };
      
      // Construction du contenu complet
      const mdxContent = `---
${Object.entries(frontmatter).map(([key, value]) => {
  if (typeof value === 'object') {
    return `${key}: ${JSON.stringify(value, null, 2)}`;
  } else if (key === 'published') {
    // G√©rer sp√©cifiquement le bool√©en published
    return `${key}: ${value}`;
  } else if (key === 'publishDate') {
    // G√©rer sp√©cifiquement la date
    return `${key}: ${value}`;
  } else if (typeof value === 'string' && (value.includes('\n') || value.includes(':'))) {
    // Pour les cha√Ænes multilignes ou contenant des caract√®res sp√©ciaux, utiliser le format bloc
    return `${key}: >-\n  ${value.replace(/\n/g, '\n  ')}`;
  } else {
    // Pour les cha√Ænes simples, les mettre entre guillemets pour √©viter les probl√®mes
    return `${key}: "${value.toString().replace(/"/g, '\\"')}"`;
  }
}).join('\n')}
---

`;
      
      return {
        slug,
        content: mdxContent
      };
    } catch (error) {
      console.error(`‚ùå Erreur lors de la conversion de la fiche "${fiche.Title || 'sans titre'}":`, error);
      return null;
    }
  }).filter(Boolean); // Filtrer les fiches nulles en cas d'erreur
}

/**
 * Nettoie uniquement les fiches sp√©cifi√©es du r√©pertoire
 * @param {Array} fichesToRemove - Liste des fiches √† supprimer
 */
function cleanSpecificFiches(fichesToRemove) {
  try {
    if (!fs.existsSync(FICHES_DIR)) {
      fs.mkdirSync(FICHES_DIR, { recursive: true });
      console.log(`üìÅ R√©pertoire cr√©√©: ${FICHES_DIR}`);
      return;
    }
    
    if (fichesToRemove.length === 0) {
      console.log(`‚ÑπÔ∏è Aucune fiche √† supprimer.`);
      return;
    }
    
    console.log(`üßπ Suppression de ${fichesToRemove.length} fiches sp√©cifiques...`);
    
    // Cr√©er un ensemble de slugs √† supprimer pour une recherche plus rapide
    const slugsToRemove = new Set(fichesToRemove.map(fiche => {
      const baseSlug = slugify(fiche.Title || 'fiche-pedagogique', {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g
      });
      
      const edition = fiche.Edition || EDITION_YEAR;
      return `${edition}-${baseSlug}-${fiche.Id}`;
    }));
    
    // Lire tous les fichiers MDX dans le r√©pertoire
    const files = fs.readdirSync(FICHES_DIR)
      .filter(file => file.endsWith('.mdx') && file !== 'README.md');
    
    let removedCount = 0;
    
    // Supprimer les fichiers correspondant aux slugs √† supprimer
    for (const file of files) {
      // Extraire le slug du nom de fichier (sans l'extension .mdx)
      const fileSlug = file.replace('.mdx', '');
      
      // V√©rifier si ce fichier correspond √† une fiche √† supprimer
      for (const slugToRemove of slugsToRemove) {
        if (fileSlug.includes(slugToRemove) || fileSlug.includes(`-${slugToRemove.split('-').pop()}.mdx`)) {
          const filePath = path.join(FICHES_DIR, file);
          fs.unlinkSync(filePath);
          removedCount++;
          break;
        }
      }
    }
    
    console.log(`‚úÖ ${removedCount} fiches supprim√©es.`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de la suppression des fiches sp√©cifiques:`, error);
  }
}

/**
 * Sauvegarde les fiches MDX dans des fichiers
 */
async function saveFichesToFiles(fiches) {
  console.log(`üíæ Sauvegarde de ${fiches.length} fiches p√©dagogiques...`);
  
  // Cr√©er le r√©pertoire s'il n'existe pas
  if (!fs.existsSync(FICHES_DIR)) {
    fs.mkdirSync(FICHES_DIR, { recursive: true });
  }
  
  for (const fiche of fiches) {
    try {
      const filePath = path.join(FICHES_DIR, `${fiche.slug}.mdx`);
      fs.writeFileSync(filePath, fiche.content, 'utf8');
      console.log(`‚úÖ Fiche sauvegard√©e: ${filePath}`);
    } catch (error) {
      console.error(`‚ùå Erreur lors de la sauvegarde de la fiche "${fiche.title}":`, error);
    }
  }
}

/**
 * Fonction principale
 */
async function main() {
  console.log('üöÄ D√©marrage de la g√©n√©ration des fiches p√©dagogiques...');
  
  try {
    // R√©cup√©rer les fiches depuis NocoDB
    const response = await fetchFichesPedagogiques();
    const fiches = response.list || [];
    
    // V√©rifier si les donn√©es ont chang√©
    const { hasChanges, changedItems, removedItems, addedItems } = checkIfDataChanged(fiches);
    
    // Sauvegarder les donn√©es brutes
    saveRawData(response, RAW_DATA_FILENAME);
    
    if (!hasChanges) {
      console.log('‚úÖ Aucune modification d√©tect√©e. Aucune action n√©cessaire.');
      return;
    }
    
    console.log('üîÑ Des modifications ont √©t√© d√©tect√©es, mise √† jour des fiches en cours...');
    
    // Supprimer uniquement les fiches qui ont √©t√© modifi√©es ou supprim√©es
    const fichesToRemove = [...changedItems, ...removedItems];
    cleanSpecificFiches(fichesToRemove);
    
    // Convertir uniquement les fiches modifi√©es ou ajout√©es
    const fichesToGenerate = [...changedItems, ...addedItems];
    const mdxFiches = convertFichesToMDX(fichesToGenerate);
    
    // Sauvegarder les fiches
    await saveFichesToFiles(mdxFiches);
    
    console.log('‚ú® G√©n√©ration des fiches p√©dagogiques termin√©e avec succ√®s!');
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration des fiches p√©dagogiques:', error);
  }
}

// Ex√©cution du script
main().catch(error => {
  console.error('‚ùå Erreur fatale:', error);
  process.exit(1);
}); 